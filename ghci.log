GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/risa/bprog2022/.ghci
2022-05-19 15:41:29.037807213
>>> 17*13
221
2022-05-19 15:54:20.180077724
>>> 5*4
20
2022-05-19 15:54:37.191217079
>>> 4+1+2+3
10
2022-05-19 15:55:10.845010089
>>> 5-4-8
-7
2022-05-19 15:55:40.426248077
>>> (5+5)/2
5.0
2022-05-19 15:57:35.797892815
>>> sqrt

<interactive>:6:1: error:
    • No instance for (Show (Double -> Double))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-05-19 15:58:15.587730691
>>> sqrt 2
1.4142135623730951
2022-05-19 15:59:04.583381476
>>> sqrt 16
4.0
2022-05-19 15:59:34.171657378
>>> double

<interactive>:9:1: error: Variable not in scope: double
2022-05-19 16:02:14.752309083
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/risa/bprog2022/.ghci
2022-05-26 15:02:29.033038187
>>> maxBound :: Int
9223372036854775807
2022-05-26 15:03:24.738070631
>>> 2 ^ 63 - 1
9223372036854775807
2022-05-26 15:05:11.96070986
>>> minBound :: Int
-9223372036854775808
2022-05-26 15:05:31.32097825
>>> :e src/First.hs
   1  module First where
   2  
   3      double :: Int -> Int
   4      double x = x + x
Ok, no modules loaded.
2022-05-26 15:49:38.194048459
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-05-26 15:49:38.226871325
>>> :e
   1  module First where
   2  
   3      double :: Int -> Int
   4      double x = x + x
Ok, one module loaded.
2022-05-26 15:56:07.39215265
>>> double 3
6
2022-05-26 15:56:29.466789891
>>> double 123
246
2022-05-26 15:56:42.496716365
>>> double ( 1 + 3 )
8
2022-05-26 15:57:09.677526258
>>> double ( 1 + 2 )
6
2022-05-26 15:57:34.716659581
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/risa/bprog2022/.ghci
2022-06-09 14:55:13.949177254
>>> 2 + 3 * 4
14
2022-06-09 14:57:55.09699355
>>> ( 2 + 3 ) * 4
20
2022-06-09 15:00:34.21635814
>>>  :i sqrt
type Floating :: * -> Constraint
class Fractional a => Floating a where
  ...
  sqrt :: a -> a
  ...
  	-- Defined in ‘GHC.Float’
2022-06-09 15:00:56.39528814
>>> sqrt (3 ^ 2 + 4 ^ 2)
5.0
2022-06-09 15:03:56.672461104
>>> sqrt (25 :: Int)

<interactive>:5:1: error:
    • No instance for (Floating Int) arising from a use of ‘sqrt’
    • In the expression: sqrt (25 :: Int)
      In an equation for ‘it’: it = sqrt (25 :: Int)
2022-06-09 15:08:17.301924433
>>> sqrt (25::Double)
5.0
2022-06-09 15:09:47.713799868
>>> hoge 25 :: Int

<interactive>:7:1: error: Variable not in scope: hoge :: t0 -> Int
2022-06-09 15:13:30.802103162
>>> head [1, 2, 3]
1
2022-06-09 15:46:26.735402589
>>> head [3, 1, 4, 1, 5]
3
2022-06-09 15:46:56.248862914
>>> head []
*** Exception: Prelude.head: empty list
2022-06-09 15:48:41.842561025
>>> hoge = [3, 1, 4, 1, 5] :: [Int]
2022-06-09 15:50:33.897720197
>>> hoge
[3,1,4,1,5]
2022-06-09 15:51:09.629380296
>>> head hoge
3
2022-06-09 15:51:26.6024282
>>> tail hoge
[1,4,1,5]
2022-06-09 15:51:33.216950734
>>> tail []
*** Exception: Prelude.tail: empty list
2022-06-09 15:52:30.806486917
>>> hoge !! 0
3
2022-06-09 15:55:12.282987797
>>> hoge 2 !! hoge

<interactive>:17:1: error:
    • Couldn't match expected type: t0 -> [a]
                  with actual type: [Int]
    • The function ‘hoge’ is applied to one value argument,
        but its type ‘[Int]’ has none
      In the first argument of ‘(!!)’, namely ‘hoge 2’
      In the expression: hoge 2 !! hoge
    • Relevant bindings include it :: a (bound at <interactive>:17:1)

<interactive>:17:11: error:
    • Couldn't match expected type ‘Int’ with actual type ‘[Int]’
    • In the second argument of ‘(!!)’, namely ‘hoge’
      In the expression: hoge 2 !! hoge
      In an equation for ‘it’: it = hoge 2 !! hoge
2022-06-09 15:56:26.270271209
>>> take 3 hoge
[3,1,4]
2022-06-09 15:56:41.308223049
>>> hoge
[3,1,4,1,5]
2022-06-09 15:57:01.264618279
>>> drop 3 hoge
[1,5]
2022-06-09 15:57:23.223539495
>>> hoge !! 5
*** Exception: Prelude.!!: index too large
2022-06-09 15:58:54.658395002
>>> take 10 hoge
[3,1,4,1,5]
2022-06-09 15:59:35.552371968
>>> drop 10 hoge
[]
2022-06-09 15:59:45.758499683
>>> length head

<interactive>:24:1: error:
    • No instance for (Foldable ((->) [a0]))
        arising from a use of ‘length’
    • In the expression: length head
      In an equation for ‘it’: it = length head
2022-06-09 16:00:56.898689796
>>> length hoge
5
2022-06-09 16:01:21.438874674
>>> length []
0
2022-06-09 16:01:40.436868312
>>> sum hoge
14
2022-06-09 16:02:18.368165771
>>> product hoge
60
2022-06-09 16:02:34.938704471
>>> hoge ++ hoge
[3,1,4,1,5,3,1,4,1,5]
2022-06-09 16:04:55.375313301
>>> reverse hoge
[5,1,4,1,3]
2022-06-09 16:05:33.648257385
>>> load src/First.hs

<interactive>:31:10: error:
    Not in scope: ‘First.hs’
    No module named ‘First’ is imported.
2022-06-09 16:07:50.775027822
>>> double 3 + 3

<interactive>:32:1: error: Variable not in scope: double :: t0 -> a
2022-06-09 16:08:07.426098569
>>> :e src/First.hs
   1  module First where
   2  
   3      double :: Int -> Int
   4      double x = x + x
Ok, no modules loaded.
2022-06-09 16:09:08.547194883
>>> :load src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:09:08.585520656
>>> double 3 + 3
9
2022-06-09 16:09:27.281086715
>>> quadruple 2

<interactive>:36:1: error:
    Variable not in scope: quadruple :: t0 -> t
2022-06-09 16:15:57.367201096
>>> git add .

<interactive>:37:10: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-06-09 16:17:31.556506477
>>> :
Ok, no modules loaded.
2022-06-09 16:18:27.147501924
>>> :quit
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/risa/bprog2022/.ghci
2022-06-16 15:02:28.136547587
>>> take 3 [3,1,4,1,5]
[3,1,4]
2022-06-16 15:04:21.233473544
>>> :e src/First.hs
   1  module First where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
Ok, no modules loaded.
2022-06-16 15:10:48.217000854
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:10:48.250862977
>>> double

<interactive>:4:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-16 15:12:18.602114403
>>> take (double 2) [1,2,3,4,5]
[1,2,3,4]
2022-06-16 15:15:07.960057604
>>> [1 .. 10]
[1,2,3,4,5,6,7,8,9,10]
2022-06-16 15:20:29.124547836
>>> :e
   1  module First where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
   8  
   9      factorial ::Integer -> Integer
  10      factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:21:05.550201328
>>> factorial 3
6
2022-06-16 15:22:10.641291764
>>> factorial 4
24
2022-06-16 15:22:22.766172969
>>> average [1,2,3,4,5]

<interactive>:10:1: error:
    Variable not in scope: average :: [a0] -> t
2022-06-16 15:38:31.756436837
>>> :e
   1  module First where
   2  
   3      double :: Int -> Int
   4      double x = x + x
   5  
   6      quadruple :: Int -> Int
   7      quadruple x = double (double x)
   8  
   9      factorial ::Integer -> Integer
  10      factorial n = product [1 .. n]
  11  
  12      average :: [Int] -> Int
  13      average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:15:1: error: parse error on input ‘ave’
   |
15 | ave :: [Int] -> Int 
   | ^^^
Failed, no modules loaded.
2022-06-16 15:39:13.833851053
>>> average [1,2,3,4,5]

<interactive>:12:1: error:
    Variable not in scope: average :: [a0] -> t
2022-06-16 15:39:26.856409572
>>> ave [1,2,3,4,5]

<interactive>:13:1: error: Variable not in scope: ave :: [a0] -> t
2022-06-16 15:39:45.141559938
>>> 
2022-06-16 15:43:55.732505332
>>> 
2022-06-16 15:43:55.861404577
>>> 
2022-06-16 15:43:56.032707958
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial ::Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:43:59.994968334
>>> average [1,2,3,4,5]
3
2022-06-16 15:44:22.024264746
>>> :t take 3 [1,2,3,4,5]
take 3 [1,2,3,4,5] :: Num a => [a]
2022-06-16 15:50:03.028395194
>>> init [1 .. 5]
[1,2,3,4]
2022-06-16 16:07:01.515910754
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial ::Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) =[]
  20  myinit (x:xs) = x : (init xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 16:14:45.974790657
>>> myinit [1 .. 5]
[1,2,3,4]
2022-06-16 16:15:13.252398353
>>> myinit []
*** Exception: src/First.hs:(19,1)-(20,29): Non-exhaustive patterns in function myinit

2022-06-16 16:15:31.092467544
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/risa/bprog2022/.ghci
2022-06-23 14:56:16.411441237
>>> :i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num NominalDiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.NominalDiffTime’
instance Num DiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.DiffTime’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
2022-06-23 14:56:30.308702095
>>> 1== 2
False
2022-06-23 15:06:20.841351608
>>>  1 < 2
True
2022-06-23 15:06:33.260853243
>>>  1 < 1
False
2022-06-23 15:06:47.466708365
>>>  1 >= 2
False
2022-06-23 15:07:03.616412432
>>> 1>-2

<interactive>:6:2: error:
    • Variable not in scope: (>-) :: t0 -> t1 -> t
    • Perhaps you meant one of these:
        ‘-’ (imported from Prelude), ‘>=’ (imported from Prelude),
        ‘>>’ (imported from Prelude)
2022-06-23 15:07:18.870365882
>>> 'a' < 'b'
True
2022-06-23 15:11:37.233485354
>>> 'a' < 'B'
False
2022-06-23 15:12:00.335790142
>>> ' ' < 'a'
True
2022-06-23 15:12:49.300912591
>>> 'ab' < 'b'

<interactive>:10:1: error:
    • Syntax error on 'ab'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'ab'
2022-06-23 15:13:07.819234185
>>> 1 /= 2
True
2022-06-23 15:16:01.109949606
>>> 1 /= 1
False
2022-06-23 15:16:11.263062823
>>> ;info abs

<interactive>:13:2: error:
    Parse error: module header, import declaration
    or top-level declaration expected.
2022-06-23 15:30:17.021731962
>>> :info abs
type Num :: * -> Constraint
class Num a where
  ...
  abs :: a -> a
  ...
  	-- Defined in ‘GHC.Num’
2022-06-23 15:30:38.437277516
>>> abs

<interactive>:15:1: error:
    • No instance for (Show (Integer -> Integer))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-23 15:30:49.112721551
>>> abs (-234)
234
2022-06-23 15:34:58.324721627
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/risa/bprog2022/.ghci
2022-06-30 14:57:20.044274047
>>> [ x ^ 2 | x <- [1 .. 5]　]
[1,4,9,16,25]
2022-06-30 15:01:57.559340456
>>> [ x * | x <- [1 .. 5] ]

<interactive>:2:3: error:
    A section must be enclosed in parentheses thus: (x *)
2022-06-30 15:12:32.977847058
>>> map (^2) [1 .. 5]
[1,4,9,16,25]
2022-06-30 15:13:17.527768227
>>> [ x `div` 2 | x <- [1 ..5]]
[0,1,1,2,2]
2022-06-30 15:14:13.311518044
>>> [ x `divMod` 2 | x <- [1 ..5 ]]
[(0,1),(1,0),(1,1),(2,0),(2,1)]
2022-06-30 15:16:09.353133394
>>> [ ( x, y ) \ x <- "abc" , y <- [4,5] 

<interactive>:6:16: error:
    parse error on input ‘<-’
    Perhaps this statement should be within a 'do' block?
2022-06-30 15:21:18.657296192
>>> myconcat

<interactive>:7:1: error:
    • Variable not in scope: myconcat
    • Perhaps you meant one of these:
        ‘mconcat’ (imported from Prelude), ‘concat’ (imported from Prelude)
2022-06-30 15:27:49.01895495
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial ::Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) =[]
  20  myinit (x:xs) = x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs]
Ok, no modules loaded.
2022-06-30 15:29:47.676587508
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:29:47.759578986
>>> myconcat

<interactive>:10:1: error:
    • No instance for (Show ([[a0]] -> [a0]))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-30 15:30:17.481724922
>>> [1 | _ <- [1 .. 5] ]
[1,1,1,1,1]
2022-06-30 15:47:42.274102483
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial ::Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int 
  16  ave xs = div (sum xs) (length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) =[]
  20  myinit (x:xs) = x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs]
  24  
  25  mylength :: [a] -> Int
  26  mylength xs = sum [1 | _ <- xs]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:50:09.244572904
>>> mylength ['a' .. 'z' ]
26
2022-06-30 15:50:45.255060398
>>> ['a' .. 'z' ]
"abcdefghijklmnopqrstuvwxyz"
2022-06-30 15:51:35.520831399
>>> ['あ' .. 'ん']
"\12354\12355\12356\12357\12358\12359\12360\12361\12362\12363\12364\12365\12366\12367\12368\12369\12370\12371\12372\12373\12374\12375\12376\12377\12378\12379\12380\12381\12382\12383\12384\12385\12386\12387\12388\12389\12390\12391\12392\12393\12394\12395\12396\12397\12398\12399\12400\12401\12402\12403\12404\12405\12406\12407\12408\12409\12410\12411\12412\12413\12414\12415\12416\12417\12418\12419\12420\12421\12422\12423\12424\12425\12426\12427\12428\12429\12430\12431\12432\12433\12434\12435"
2022-06-30 15:52:02.962976232
>>> putStrln it

<interactive>:16:1: error:
    • Variable not in scope: putStrln :: [Char] -> t
    • Perhaps you meant one of these:
        ‘putStrLn’ (imported from Prelude),
        ‘putStr’ (imported from Prelude)
2022-06-30 15:53:13.656235294
>>> putStrLn it
あぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをん
2022-06-30 15:53:51.935765613
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/risa/bprog2022/.ghci
2022-07-07 16:05:24.822458445
>>> :e
No files to edit.
2022-07-07 16:05:30.025772993
>>> :l
Ok, no modules loaded.
2022-07-07 16:05:30.128579837
>>> ord 'A'

<interactive>:3:1: error:
    • Variable not in scope: ord :: Char -> t
    • Perhaps you meant one of these:
        ‘or’ (imported from Prelude), ‘odd’ (imported from Prelude)
2022-07-07 16:05:53.700725384
>>> :e src
catn: src: openFile: inappropriate type (is a directory)
2022-07-07 16:06:56.022163157
>>> :l src
target ‘src’ is not a module name or a source file
2022-07-07 16:06:56.052457782
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
Ok, no modules loaded.
2022-07-07 16:07:29.398680299
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-07 16:07:29.477975961
>>> ord 'A'
65
2022-07-07 16:07:46.09473937
>>> ord 'a'
97
2022-07-07 16:07:56.984446427
>>> import Data.Char
2022-07-07 16:11:51.6926187
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/risa/bprog2022/.ghci
2022-07-14 15:11:32.422555437
>>> :e scr/Caesa .hs
catn: scr/Caesa: openFile: does not exist (No such file or directory)
2022-07-14 15:12:08.976326467
>>> :l scr/Caesa .hs
target ‘scr/Caesa’ is not a module name or a source file
2022-07-14 15:12:09.013562807
>>> :e src/Caesar .hs
catn: src/Caesar: openFile: does not exist (No such file or directory)
2022-07-14 15:13:03.575157752
>>> :l src/Caesar .hs

<no location info>: error: can't find file: .hs
Failed, no modules loaded.
2022-07-14 15:13:03.71514462
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c 

<no location info>: error: can't find file: .hs
Failed, no modules loaded.
2022-07-14 15:13:31.726552006
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:13:31.787464003
>>> let2int 'a'
97
2022-07-14 15:13:51.517679183
>>> let2int 'z'
122
2022-07-14 15:14:09.784829413
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:15:16.242655299
>>> let2int 'a'
0
2022-07-14 15:15:39.411294688
>>> let2int 'z'
25
2022-07-14 15:16:04.96041478
>>> chr 97
'a'
2022-07-14 15:19:31.092107804
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:20:08.677404566
>>> int2let 0
'a'
2022-07-14 15:20:20.718406555
>>> int2let 25
'z'
2022-07-14 15:20:30.729278481
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | islower c = int2let((let2int c + n) `mod` 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:7: error:
    • Variable not in scope: islower :: Char -> Bool
    • Perhaps you meant ‘isLower’ (imported from Data.Char)
   |
13 |     | islower c = int2let((let2int c + n) `mod` 26)
   |       ^^^^^^^
Failed, no modules loaded.
2022-07-14 15:27:41.250812401
>>> shift (-3) 'd'

<interactive>:17:1: error:
    Variable not in scope: shift :: t0 -> Char -> t
2022-07-14 15:28:23.217096527
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:28:59.82580949
>>> shift 3 'a'
'd'
2022-07-14 15:29:15.797525549
>>> shift (-3) 'd'
'a'
2022-07-14 15:29:34.400975087
>>> shift 3 ' '
' '
2022-07-14 15:33:04.039951831
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16      encode :: Int -> (String -> String)
  17      encode n xs = [ shift n x | x <- xs ]
  18      
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:17: error: parse error on input ‘=’
   |
17 |     encode n xs = [ shift n x | x <- xs ]
   |                 ^
Failed, no modules loaded.
2022-07-14 15:36:04.333629876
>>> encode 3 "haskell is fun"

<interactive>:23:1: error:
    Variable not in scope: encode :: t0 -> t1 -> t
2022-07-14 15:36:31.633197154
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16      encode :: Int -> (String -> String)
  17      encode n xs = [ shift n x | x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:17: error: parse error on input ‘=’
   |
17 |     encode n xs = [ shift n x | x <- xs ]
   |                 ^
Failed, no modules loaded.
2022-07-14 15:38:21.368565063
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16   encode :: Int -> (String -> String)
  17   encode n xs = [ shift n x | x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:14: error: parse error on input ‘=’
   |
17 |  encode n xs = [ shift n x | x <- xs ]
   |              ^
Failed, no modules loaded.
2022-07-14 15:38:39.633439906
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/risa/bprog2022/.ghci
2022-07-14 15:45:21.83053453
>>> :e
No files to edit.
2022-07-14 15:45:26.88565528
>>> :l
Ok, no modules loaded.
2022-07-14 15:45:26.991197794
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16   encode :: Int -> (String -> String)
  17   encode n xs = [ shift n x | x <- xs ]
Ok, no modules loaded.
2022-07-14 15:45:57.467056059
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:17:14: error: parse error on input ‘=’
   |
17 |  encode n xs = [ shift n x | x <- xs ]
   |              ^
Failed, no modules loaded.
2022-07-14 15:45:57.497379438
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:46:31.127343916
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:47:09.004974808
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:48:13.491005255
>>> it
"kdvnhoo lv ixq"
2022-07-14 15:48:26.286808367
>>> encdode (-3) it

<interactive>:9:1: error:
    • Variable not in scope: encdode :: t0 -> String -> t
    • Perhaps you meant ‘encode’ (line 17)
2022-07-14 15:49:02.564712991
>>> encode (-3) it
"haskell is fun"
2022-07-14 15:49:19.559615336
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:59:21.462557518
>>> length table
26
2022-07-14 16:00:00.100239396
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:08:53.143855151
>>> percent 5 15
33.333336
2022-07-14 16:09:03.02642901
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:14:39.097636556
>>> count 's' "Mississippi"
4
2022-07-14 16:15:23.094308207
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/risa/bprog2022/.ghci
2022-07-21 15:07:30.789680461
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30   freqs :: String -> [Float]
  31   freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32      where
  33          n = length xs
Ok, no modules loaded.
2022-07-21 15:08:07.861528632
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:31:11: error: parse error on input ‘=’
   |
31 |  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
   |           ^
Failed, no modules loaded.
2022-07-21 15:08:07.925930664
>>> ...

<interactive>:3:1: error: parse error on input ‘...’
2022-07-21 15:10:43.501436895
>>> 1 + 1
2
2022-07-21 15:11:13.886422457
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30   freqs :: String -> [Float]
  31   freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32      where
  33          n = length xs
  34  sample :: String
  35  sample = "abbcccddddeeeee"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:31:11: error: parse error on input ‘=’
   |
31 |  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
   |           ^
Failed, no modules loaded.
2022-07-21 15:20:15.559608787
>>> length sample

<interactive>:6:8: error: Variable not in scope: sample :: t0 a0
2022-07-21 15:20:50.976526552
>>> sample

<interactive>:7:1: error: Variable not in scope: sample
2022-07-21 15:20:58.558618493
>>> :r:
unknown command ':r:'
use :? for help.
2022-07-21 15:22:20.237106673
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30   freqs :: String -> [Float]
  31   freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32      where
  33          n = length xs
  34  sample :: String
  35  sample = "abbcccddddeeeee"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:31:11: error: parse error on input ‘=’
   |
31 |  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
   |           ^
Failed, no modules loaded.
2022-07-21 15:22:23.134013032
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30   freqs :: String -> [Float]
  31   freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32      where
  33          n = length xs
  34  sample :: String
  35   sample = "abbcccddddeeeee"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:31:11: error: parse error on input ‘=’
   |
31 |  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
   |           ^
Failed, no modules loaded.
2022-07-21 15:22:41.50162251
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30   freqs :: String -> [Float]
  31   freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  32      where
  33          n = length xs
  34  sample :: String
  35  sample = "abbcccddddeeeee"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:31:11: error: parse error on input ‘=’
   |
31 |  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
   |           ^
Failed, no modules loaded.
2022-07-21 15:23:09.607479535
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:24:07.39895122
>>> length sample
15
2022-07-21 15:24:20.247450341
>>> sample
"abbcccddddeeeee"
2022-07-21 15:24:26.394240784
>>> freqs sample
[6.666667,13.333334,20.0,26.666668,33.333336,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
2022-07-21 15:24:41.427503983
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 /e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:38:56.46619244
>>> rotate 3 [1,2,3,4,5]
[4,5,1,2,3]
2022-07-21 15:40:01.325089159
>>> [chisqr (rotate n table') table |n <- [0 .. 25] ]

<interactive>:18:19: error:
    • Variable not in scope: table' :: [Float]
    • Perhaps you meant ‘table’ (line 20)
2022-07-21 15:49:01.825827241
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 /e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  table' :: [Float]
  45  table' = freqs "kdvnhoo lv ixq"
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 15:49:12.075992634
>>>  [chisqr (rotate n table') table |n <- [0 .. 25] ]
[1037.1161,472.26096,451.96503,150.75772,1059.9601,3122.5193,480.326,857.7907,716.2974,731.72504,367.52783,1095.8976,1689.1488,1036.0608,1097.8545,2231.09,486.6004,2085.8784,725.49756,596.9133,964.8147,627.002,2138.5535,703.25635,3905.8936,462.25485]
2022-07-21 15:49:43.843927004
>>> posoto

<interactive>:21:1: error: Variable not in scope: posoto
2022-07-21 15:58:54.605698515
>>> 
2022-07-21 15:58:54.795921761
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 /e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  table' :: [Float]
  45  table' = freqs "kdvnhoo lv ixq"
  46  
  47  sampleAngou :: String
  48  sampleAngou = "kdvnhoo lv ixq"
  49  
  50  crack :: String -> String
  51  crack xs = encode (-factor) xs
  52      where
  53          factor = head ((minimum chitab) chitab)
  54          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  55          table' = freqs xs
  56  
  57  positions :: Eq a => a -> [a] -> [Int]
  58  positions x xs = [ i | (x', i) <- zip xs [0 ..]]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:53:24: error:
    • Couldn't match expected type ‘[Float] -> [a]’
                  with actual type ‘Float’
    • The function ‘minimum’ is applied to two value arguments,
        but its type ‘[Float] -> Float’ has only one
      In the first argument of ‘head’, namely ‘((minimum chitab) chitab)’
      In the expression: head ((minimum chitab) chitab)
    • Relevant bindings include
        factor :: a (bound at src/Caesar.hs:53:9)
   |
53 |         factor = head ((minimum chitab) chitab)
   |                        ^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-21 15:59:21.471435874
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 /e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  table' :: [Float]
  45  table' = freqs "kdvnhoo lv ixq"
  46  
  47  sampleAngou :: String
  48  sampleAngou = "kdvnhoo lv ixq"
  49  
  50  crack :: String -> String
  51  crack xs = encode (-factor) xs
  52      where
  53          factor = head ((minimum chitab) chitab)
  54          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  55          table' = freqs xs
  56  
  57  positions :: Eq a => a -> [a] -> [Int]
  58  positions x xs = [ i | (x', i) <- zip xs [0 ..], x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:53:24: error:
    • Couldn't match expected type ‘[Float] -> [a]’
                  with actual type ‘Float’
    • The function ‘minimum’ is applied to two value arguments,
        but its type ‘[Float] -> Float’ has only one
      In the first argument of ‘head’, namely ‘((minimum chitab) chitab)’
      In the expression: head ((minimum chitab) chitab)
    • Relevant bindings include
        factor :: a (bound at src/Caesar.hs:53:9)
   |
53 |         factor = head ((minimum chitab) chitab)
   |                        ^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-21 15:59:54.748000071
>>> positions False

<interactive>:25:1: error:
    Variable not in scope: positions :: Bool -> t
2022-07-21 16:00:16.377408458
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 /e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs "kdvnhoo lv ixq"
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head ((minimum chitab) chitab)
  55          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
  57  
  58  positions :: Eq a => a -> [a] -> [Int]
  59  positions x xs = [ i | (x', i) <- zip xs [0 ..], x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:54:24: error:
    • Couldn't match expected type ‘[Float] -> [a]’
                  with actual type ‘Float’
    • The function ‘minimum’ is applied to two value arguments,
        but its type ‘[Float] -> Float’ has only one
      In the first argument of ‘head’, namely ‘((minimum chitab) chitab)’
      In the expression: head ((minimum chitab) chitab)
    • Relevant bindings include
        factor :: a (bound at src/Caesar.hs:54:9)
   |
54 |         factor = head ((minimum chitab) chitab)
   |                        ^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-21 16:02:32.166991312
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let i = chr (i + ord 'a')
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c 
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs ]
  18  
  19  table :: [Float]
  20  table = [8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4, 6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0, 2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
  30  
  31  freqs :: String -> [Float]
  32  freqs xs = [ percent (count x xs) n | x <- ['a' .. 'z']]
  33      where
  34          n = length xs
  35  
  36  sample :: String
  37  sample = "abbcccddddeeeee"
  38  
  39  chisqr :: [Float] -> [Float] -> Float
  40  chisqr os es = sum [ (o - e)^2 /e | (o, e) <- zip os es ]
  41  
  42  rotate :: Int -> [a] -> [a]
  43  rotate n xs = drop n xs ++ take n xs
  44  
  45  table' :: [Float]
  46  table' = freqs "kdvnhoo lv ixq"
  47  
  48  sampleAngou :: String
  49  sampleAngou = "kdvnhoo lv ixq"
  50  
  51  crack :: String -> String
  52  crack xs = encode (-factor) xs
  53      where
  54          factor = head (positions(minimum chitab) chitab)
  55          chitab = [chisqr (rotate n table') table | n <- [0 .. 25]]
  56          table' = freqs xs
  57  
  58  positions :: Eq a => a -> [a] -> [Int]
  59  positions x xs = [ i | (x', i) <- zip xs [0 ..], x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-21 16:03:04.000042844
>>> positions False

<interactive>:28:1: error:
    • No instance for (Show ([Bool] -> [Int]))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-07-21 16:03:33.314737524
>>> positions False [True, False, True, False]
[1,3]
2022-07-21 16:04:42.63804064
>>> "haskell is fun"
"haskell is fun"
2022-07-21 16:05:10.704362197
>>> crack "vscd mywzboroxcsyxc kbo ecopev"
"list comprehensions are useful"
2022-07-21 16:07:25.093487197
>>> :q
Leaving GHCi.
